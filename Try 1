//-------------------------------------------------
//! Solves a square equation ax2 + bx + c = 0
//!
//! @param [in] a a-coefficient
//! @param [in] b b-coefficient
//! @param [in] c c-coefficient
//! @param [out] x1 first root
//! @param [out] x2 second root
//!
//! @return number of roots
//!
//! @note   INF_ROOTS - infinity numbers of roots
//!
//-------------------------------------------------

#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#define INF_ROOTS -1
#define NO_ROOTS  0
#define ONE_ROOT  1
#define TWO_ROOTS 2
#define EPS 0.00000001

struct square
{
    double a;
    double b;
    double c;
    double* x1;
    double* x2;
};

int SquareSolver(struct square first);
int Compare_with_null(double n);
int Clear_board();
int RunTest(double a, double b, double c, double expected_x1, double expected_x2, int expected_numRoots);


int main()
{
    printf("If you want to solve the square print 1\n");
    printf("If you want to check tests print 2\n");

    int flag;
    scanf("%d", &flag);

    if (flag == 1)
    {
        double x1 = 0, x2 = 0;
        struct square first = {};
        first.x1 = &x1;
        first.x2 = &x2;

        printf("# SquareSolver\n" "# (c), Ann, 2024\n");
        printf("# Enter a, b, c: ");


        while (scanf("%lg %lg %lg", &first.a, &first.b, &first.c) != 3)
        {
            Clear_board();

            printf("Enter again please\n");
        }

        int NumRoots = SquareSolver(first);

        switch (NumRoots)
        {
            case NO_ROOTS:

                printf("No solutions\n");

                break;


            case ONE_ROOT:

                printf("x = %lg\n", *first.x1);

                break;


            case TWO_ROOTS:

                printf("x1 = %lg, x2 = %lg\n", *first.x1, *first.x2);

                break;

            case INF_ROOTS:

                printf("Any number\n");

                break;

        }
    }
    else
        CheckProgram();
}

int SquareSolver(struct square first)
{
    assert(first.x1 != NULL);
    assert(first.x2 != NULL);
    assert(first.x1 != first.x2);

    if (Compare_with_null(first.a))
    {
        if (Compare_with_null(first.b))
        {
            return (Compare_with_null(first.c)) ? INF_ROOTS : NO_ROOTS;
        }
        else
        {
            *first.x1 = -first.c / first.b;
            return ONE_ROOT;
        }
    }
    else
    {
        if (first.b == 0)
        {
            if (first.c == 0)
            {
                *first.x1 = 0;
                return ONE_ROOT;
            }
            else
            {
                if (-first.c / first.a >= 0)
                {
                    *first.x1 = sqrt(-first.c / first.a);
                    *first.x2 = -sqrt(-first.c / first.a);
                    return TWO_ROOTS;
                }
                else
                    return NO_ROOTS;
            }
        }
        else
        {
            if ((pow(first.b, 2) - 4 * first.a * first.c) > 0)
            {
                *first.x1 = (-first.b + sqrt(pow(first.b, 2) - 4 * first.a * first.c)) / (2 * first.a);
                *first.x2 = (-first.b - sqrt(pow(first.b, 2) - 4 * first.a * first.c)) / (2 * first.a);
                return TWO_ROOTS;
            }
            else if ((pow(first.b, 2) - 4 * first.a * first.c) < 0)
                return NO_ROOTS;
            else
            {
                *first.x1 = (-first.b + sqrt(pow(first.b, 2) - 4 * first.a * first.c)) / (2 * first.a);
                return ONE_ROOT;
            }
        }
    }

}

int Compare_with_null(double n)
{
    if (fabs(n) < EPS)
        return 1;
    else
        return 0;
}

int Clear_board()
{
        int symbol = 0;

        while ((symbol = getchar()) != '\n')
        {
            ;
        }
}


int RunTest(double a, double b, double c, double expected_x1, double expected_x2, int expected_numRoots)
{
    double x1 = 0, x2 = 0;
    struct square test = {.a = a, .b = b, .c = c, .x1 = &x1, .x2 = &x2};
    int numRoots = SquareSolver(test);
    if (numRoots != expected_numRoots || x1 != expected_x1 || x2 != expected_x2)
    {
        printf("\nError Test, a = %lg, b = %lg, c = %lg, x1 = %lg, x2 = %lg, numRoots = %lg"
              "Expected x1 = %lg, x2 = %lg, numRoots = %lg\n", test.a, test.b, test.c,
              x1, x2, numRoots, expected_x1, expected_x2, expected_numRoots);
        return 0;
    }
    else
        return 1;

}

void CheckProgram()
{
    int ans[10];
    ans[0] = RunTest(1,  4,  3,   -1,   -3,   2); //D > 0, два корня
    ans[1] = RunTest(1,  2,  3,    0,    0,   0); //D < 0, нет корней
    ans[2] = RunTest(1, -2,  1,    1,    0,   1); //D = 0, один корень
    ans[3] = RunTest(1,  5, 2.25, -0.5, -4.5, 2); //Дробный коэффициент
    ans[4] = RunTest(0,  0,  0,    0,    0,  -1); //a = 0, b = 0, c = 0, бесконечные решения
    ans[5] = RunTest(0,  0,  1,    0,    0,   0); //a = 0, b = 0, нет корней
    ans[6] = RunTest(0,  5,  1,   -0.2,  0,   1); //а = 0, один корень
    ans[7] = RunTest(1,  0, -4,    2,   -2,   2); //b = 0, два корня
    ans[8] = RunTest(1,  0,  0,    0,    0,   1); //b = 0, с = 0, один корень
    ans[9] = RunTest(4,  2,  0,    0,   -0.5, 2); //с = 0, два корня
    int i = 0;
    while (i < 10)
    {
        printf("Test %d: %d ", i + 1, ans[i]);
        i++;
    }

}
